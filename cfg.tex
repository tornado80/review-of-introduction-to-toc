\documentclass[main.tex]{subfiles}



\begin{document}
	گرامر‌ها
	\LTRfootnote{Context Free Grammar}
	 یک مدل محاسباتی هستند و برخلاف اتوماتا‌های متناهی که کلمات یک زبان را با قرار گرفتن در استیت اکسپت پذیرش می‌کنند، کلمات زبانی را به کمک تعدادی قاعده
	\LTRfootnote{\lr{Production Rule}}
	تولید می‌کنند.
	\begin{definition}
		گرامر مستقل از متن یک چهار‌تایی 
		$G = (V, \Sigma, S, P)$
		است که به ترتیب $V$ مجموعه متناهی متغیر‌های گرامر، 
		$\Sigma$
		مجموعه متناهی حروف الفبا، $S$ متغیر شروع گرامر ($S \in V$) و $P$ مجموعه متناهی از قواعد که به فرم 
		$A \rightarrow \alpha$
		هستند که 
		$A \in V$ 
		و
		$\alpha \in (V \cup \Sigma)^*$.
	\end{definition}
	
	\begin{example}
		گرامر زیر زبان 
		$L = \{a^nb^n \, | \, n \in \mathbb{N}\}$
		را تولید می‌کند. (زبان $ AnBn $)
		\begin{align*}
			G &= (\{S\}, \{a, b\}, S, \{S \rightarrow aSb, S \rightarrow \Lambda\}) \\
			S &\rightarrow aSb \\
			S &\rightarrow \Lambda
		\end{align*}
	یا به طور خلاصه
	$S \rightarrow aSb \, | \, \Lambda$.
	واضح است که 
	$\Lambda \in (V \cup \Sigma)^*$
	و به معنای قابلیت جایگزینی $S$ با رشته تهی است؛ در نتیجه تولید یا پروداکشن می‌تواند خاتمه یابد. همچنین به حروف 
	$\Sigma$
	ترمینال نیز گفته می‌شود.
	\end{example}
	
	برای نشان دادن نحوه تولید یک کلمه به کمک زبان از نماد های 
	$\Rightarrow$،
	$\Rightarrow^*$
	و
	$\Rightarrow^n$
	استفاده می‌شود.
	
	\begin{example}
		گرامر $G$ که در بالا توصیف شد را در نظر بگیرید، رشته 
		$aabb$
		به صورت زیر از قواعد گرامر مشتق
		\LTRfootnote{Derivation}
		 می‌شود:
		 $$S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aa\Lambda bb \Rightarrow aabb$$
		یا به طور خلاصه 
		$S \Rightarrow^{*}_G aabb$
		نوشته می‌شود که یعنی با تعدادی مرحله به رشته مذکور می‌رسیم. همچنین با زیرنویس $G$ مشخص می‌کنیم که از قواعد گرامر $G$ استفاده شده‌است.
	\end{example}
	
	\begin{definition}
	اگر 
	$G = (V, \Sigma, S, P)$
	یک 
	گرامر مستقل از متن باشد، منظور از زبان تولید شده توسط $G$، 
	$$L(G) = \{x \in \Sigma^* \, | \, S \Rightarrow^{*}_G x \}$$
	است. زبانی مستقل از متن است اگر گرامر مستقل از متنی وجود داشته باشد که آن را تولید کند.
	\end{definition}
	
	\begin{example}
	زبان حاوی کلمات پالیندروم، زبانی مستقل از متن است. (زبان $ Pal $)
	
	گرامر مستقل از متن زیر را داریم: (با فرض 
	$\Sigma = \{a, b\}$)
	$$S \rightarrow aSa \, | \, bSb \, | \, \Lambda$$
	\end{example}

	\begin{example}
	زبان حاوی کلماتی که تعداد $a$ در آنها با تعداد $b$ برابر است، زبانی مستقل از متن است. (زبان $ AEqB $)
	
	گرامر مستقل از متن زیر را داریم: (با فرض 
	$\Sigma = \{a, b\}$)
	$$S \rightarrow aSbS \, | \, bSaS \, | \, \Lambda$$
	\begin{proof}
		باید نشان دهیم هر کلمه مثل $x$ که 
		$n_a(x) = n_b(x)$
	توسط این قواعد تولید می‌شود و همچنین باید ثابت کنیم هر کلمه‌ای که توسط این قواعد تولید می‌شود چنین ویژگی را دارد. گزاره دوم واضح است. گزاره اول را ثابت می‌کنیم. به استقرای قوی حکم را روی 
	$|x|$
	ثابت می‌کنیم. پایه اسقرا 
	$x = \Lambda$
	است که توسط گرامر تولید می‌شود. اکنون فرض کنید حکم برای همه رشته‌های به طول زوج کوچکتر از $|x|$ برقرار باشد، حکم را برای $x$ نشان می‌دهیم. تابع 
	$f : \Sigma* \rightarrow \mathbb{Z}$
	را با ضابطه 
	$f(x) = n_a(x) - n_b(x)$
	تعریف می‌کنیم. همچنین فرض می‌کنیم
	$x = x_1x_2\dots x_n$
	($x_i \in \Sigma$). 
	بدون کاسته شدن از کلیت مسئله فرض کنید $x_1 = a$. اولین $i$ که 
	$f(x_1x_2\dots x_i) = 0$
   را در نظر می‌گیریم. در این صورت نتیجه می‌شود $x_i = b$. پس 
   $x_2\dots x_{i-1} \in AEqB$
   و همچنین
   $x_{i+1}\dots x_n \in AEqB$. 
   طبق فرض استقرا این دو کلمه به کمک قواعد $G$ از متغیر $S$ قابل تولیدند. با توجه به قاعده 
   $S \rightarrow aSbS$
   کلمه $x$ نیز توسط گرامر قابل تولید است.
	\end{proof}
	\end{example}

	\begin{theorem}
		اگر $L_1$ و $L_2$ زبان‌هایی مستقل از متن باشند، زبان‌های
		$L_1 \cup L_2$،
		$L_1L_2$
		و
		$L_{1}^*$
		نیز مستقل از متن هستند.
	\end{theorem}

	\begin{proof}
		فرض کنید
		 $G_1 = (V_1, \Sigma, S_1, P_1)$ 
		و
		 $G_2 = (V_2, \Sigma, S_2, P_2)$ 
	به ترتیب گرامر‌های مستقل از متن برای زبان‌های $L_1$ و $L_2$ باشند.
	
	اگر 
		$H_1 = (V_1 \cup V_2, \Sigma, S, P_1 \cup P_2 \cup \{S \rightarrow S_1 \, | \, S_2 \})$،
		آنگاه
		$L(H_1) = L_1 \cup L_2$.
		
		
		اگر
		$H_2 = (V_1 \cup V_2, \Sigma, S, P_1 \cup P_2 \cup \{S \rightarrow S_1S_2 \})$،
		آنگاه
		$L(H_2) = L_1L_2$.
		
		
		اگر
		$H_3 = (V_1, \Sigma, S, P_1 \cup P_2 \cup \{S \rightarrow SS_1 \, | \, \Lambda\})$،
		آنگاه
		$L(H_3) = L_{1}^*$.
	\end{proof}
	
	\subsection{
		گرامرهای منظم و خطی راست و چپ
	}
	
	\begin{definition}
	گرامر مستقل از متن 
	$G = (V, \Sigma, S, P)$
	را گرامر خطی راست 
	\LTRfootnote{
		Right Linear Grammars (RLG)
	}
	می‌گوییم اگر همه قواعد آن به فرم 
	$A \rightarrow \sigma B$
	یا 
	$A \rightarrow \Lambda$
	باشد که در آن
	$A, B \in V$
	و
	$\sigma \in \Sigma$.
	\end{definition}

	\begin{definition}
	گرامر مستقل از متن 
	$G = (V, \Sigma, S, P)$
	را گرامر خطی چپ 
	\LTRfootnote{
		Left Linear Grammars (LLG)
	}
	می‌گوییم اگر همه قواعد آن به فرم 
	$A \rightarrow B \sigma$
	یا 
	$A \rightarrow \Lambda$
	باشد که در آن
	$A, B \in V$
	و
	$\sigma \in \Sigma$.
	\end{definition}

	\begin{definition}
		گرامر مستقل از متن 
		$G = (V, \Sigma, S, P)$
		را گرامر منظم 
		\LTRfootnote{
			Regular Grammars
		}
		می‌گوییم اگر خطی راست یا خطی چپ باشد.
	\end{definition}

	\begin{theorem}
		زبان $L$ منظم است اگر و تنها اگر گرامر منظم $G$ وجود داشته باشد که 
		$L = L(G)$.
	\end{theorem}
	\begin{proof}
		(شهودی) اثبات معادل بودن گرامر‌های خطی راست با اتوماتا‌های متناهی ساده است. فرض کنید 
		$M = (Q, \Sigma, q_0, A, \delta)$
		یک اتوماتای متناهی قطعی 
		\LTRfootnote{Deterministic Finite Automata (DFA)}
		باشد. گرامر خطی راست 
		$G = (V, \Sigma, S, P)$
		را این‌گونه می‌سازیم. قرار می‌دهیم 
		$V = Q$
		و 
		$S = q_0$.
		همچنین برای 
		$\delta(p, \sigma) = q$
		که 
		$p, q \in Q$
		و
		$\sigma \in \Sigma$
		قاعده
		$p \rightarrow \sigma q $
		نیز در $P$ قرار خواهد داشت. ضمنا اگر 
		$r \in A$
		آنگاه قاعده 
		$r \rightarrow \Lambda$
		نیز در $P$ را دارد.
		 به سادگی می‌توان دید که 
		$L(G) = L(M)$.
		از طرفی اگر 
		$G = (V, \Sigma, S, P)$
		گرامر خطی راست باشد، اتوماتای متناهی غیر قطعی
		\footnote{
			چرا اتوماتای غیر قطعی تعریف می‌کنیم؟ چرا مستقیم سراغ قطعی نمی‌رویم؟	
		}
		\LTRfootnote{
			Nondeterministic Finite Automata
		}  
$M = (Q, \Sigma, q_0, A, \delta)$
را این‌گونه می‌سازیم. قرار می‌دهیم 
		 $Q = V$
		 و
		 $q_0 = S$.
		 همچنین تابع 
		 $\delta : Q \times \Sigma \rightarrow Q$
		  برای هر قاعده
		 $X \rightarrow \sigma Y$
		 در $P$، این‌گونه تعریف می‌کنیم 
		 $\delta(X, \sigma) = Y$
		 و
		 برای هر قاعده به فرم
		 $X \rightarrow \Lambda$،
		 $X$
		 در 
		 $A$
		 خواهد بود. دوباره به سادگی می‌توان دید که 
		 $L(M) = L(G)$.
		 
		 برای معادل بودن گرامر‌های خطی چپ کار کمی دشوارتر است. اگر  هر قاعده در یک گرامر خطی چپ مثل 
		 $X \rightarrow Y \sigma$
		 با قاعده 
		 $X \rightarrow \sigma Y$
		 جایگزین شود، زبان تولید شده توسط این گرامر شامل عکس تمام رشته‌های زبان گرامر اولیه خواهد بود. (نه فقط شامل آنها بلکه دقیقا همان‌ها می‌شود.) از طرفی در صورت داشتن یک \textbf{اتوماتای متناهی قطعی} می‌توان یک اتوماتای متناهی دیگر ساخت که دقیقا عکس کلمات پذیرفته شده توسط اتوماتای نخست را پذیرش کند. همچنین هر اتوماتای غیرقطعی معادل یک اتوماتای قطعی است. پس به کمک این دو گزاره، فرآیند زیر برای اثبات قضیه طی می‌شود:
		 $$
		 \text{گرامر خطی چپ}
		 \longleftrightarrow
		 \text{برعکس کردن قواعد}
		 \longleftrightarrow
		 \text{گرامر خطی راست}
		 \longleftrightarrow
		 \text{اتوماتای غیرقطعی}
		 \longleftrightarrow
		 \text{اتوماتای قطعی}
		 \longleftrightarrow
		 \text{اتوماتای پذیرنده معکوس کلمات}
		 $$
	\end{proof}
پس بنابر قضیه بالا \textbf{گرامر‌های منظم }قدرت محاسباتی بیشتری از اتوماتا‌های متناهی ندارند.

	\subsection{ابهام و درخت اشتقاق}
	\begin{example}
		گرامر 
		$G = (\{S\}, \{a, +, *\}, S, P)$
		با قواعد زیر مبهم است:
		\begin{align*}
			S &\rightarrow S + S \\
			S &\rightarrow S * S \\
			S &\rightarrow a
		\end{align*}
	دو درخت اشتقاق 
		\LTRfootnote{Derivation tree}
	برای کلمه 
		$a + a * a$
		در زیر کشیده شده‌اند:
		\begin{latin}
			\Tree
			[
				.$S$
				[
					.$S$
					$a$	
				]
				$+$
				[
					.$S$
					$a$
					$*$
					$a$
				]
			]
			\Tree
			[
				.$S$
				[
					.$S$
					$a$
					$+$
					$a$
				]
				$*$
				[
					.$S$
					$a$
				]
			]
		\end{latin}
	\end{example}

	پس درخت اشتقاق به صورت تصویری نشان می‌دهد برای تولید یک کلمه چه قواعدی استفاده شده‌اند.
	
	\begin{definition}
		گرامر مستقل از متن $G$ مبهم است اگر کلمه $x \in L(G)$ موجود باشد به طویکه $x$ دارای حداقل دو درخت اشتقاق باشد.
	\end{definition}

	در نتیجه گرامر فوق مبهم است. رفع ابهام نیازمند کمی خلاقیت است. در اینجا می‌توان گرامر زیر را ارائه کرد:
	\begin{align*}
		S &\rightarrow S + T \, | \, T \\
		T &\rightarrow T * T \, | \, a 
	\end{align*}
با درخت اشتقاق زیر برای کلمه $a + a * a$:
	\begin{latin}
		\Tree
		[
			.$S$
			[
				.$S$
				[
					.$T$
					$a$
				]	
			]
			$+$
			[
				.$T$
				[
					.$T$
					$a$
				]
				$*$
				[
					.$T$
					$a$
				]
			]
		]
	\end{latin}
	\subsection{فرم‌های نرمال}
	به مسئله تصمیم در گرامر‌های مستقل از متن فکر کنید. یعنی با داشتن پروداکشن‌های گرامر $G$ و رشته $x$ مشخص کنیم $x$ توسط قواعد $G$ تولید می‌شوند یا خیر.  دانستن نکاتی درباره فرم پروداکشن‌ها به ما در پاسخ به این سوال کمک می‌کند. در مراحل اشتقاق
	\LTRfootnote{Derivation steps}
	یک رشته به کمک قواعد گرامر تعداد ترمینال‌های رشته ($t$) کاهش نمی‌یابند. اگر تصور کنیم گرامر هیچ لاندا-قاعده‌ای
	\LTRfootnote{$\Lambda$-production}
	 نداشته باشد، (یعنی هیچ قاعده‌ای به فرم 
	 $X \rightarrow \Lambda$)
	 در این صورت طول رشته ($l$) نیز در مراحل اشتقاق کاهش نمی‌یابد. (در تعبیر درخت اشتقاق، تعداد رئوس در هر سطح درخت کاهش نمی‌یابد.) همچنین اگر بدانیم گرامر هیچ یونیت-پروداکشنی 
	 \LTRfootnote{Unit production}
	 (یعنی هیچ قاعده‌ای به فرم
	 $X \rightarrow Y$
	 که $Y$ متغیر باشد.)
	 نیز نداشته باشد، می‌توانیم بگوییم تعداد رئوس در هر سطح درخت اشتقاق اکیدا صعودی است. یعنی $l+ t$ اکیدا صعودی است. اما وقتی رشته $x$ تولید شده باشد داریم 
	 $l + t = |x| + |x| = 2|x|$.
	 از طرفی هنگام شروع تولید از متغیر $S$ داریم
	 $l + t = 1 + 0 = 1$.
	 در نتیجه تولید هیچ رشته‌ای بیش از
	 $2|x| - 1$
	 مرحله نیاز ندارد. پس با بررسی همه درخت های اشتقاق با حداکثر عمق 
	 $2|x| - 1$
	 می‌توانیم درباره وجود $x$ در 
	 $L(G)$
	 تصمیم بگیریم.
	 
	 در ادامه نشان می‌دهیم هر گرامر را می‌توان به گرامری تبدیل کرد که هیچ لاندا-قاعده و هیچ یونیت پروداکشنی نداشته باشد. سپس پا را فرا تر گذاشته و نشان می‌دهیم می‌توان قاعده‌ها را محدود به قاعده‌هایی به فرم 
	 $X \rightarrow YZ$
	 کرد که به فرم نرمال چامسکی
	 \LTRfootnote{Chomsky normal form}
	  معروف است. در نهایت به معرفی الگوریتم CYK 
	 \LTRfootnote{Cocke–Younger–Kasami algorithm}
	 می‌پردازیم که در مرتبه چندجمله‌ای
	  عضویت رشته دلخواه
	 $x$
	 در 
	 $L(G)$
	 را بررسی می‌کند.
	 \begin{theorem}
	 	برای هر گرامر $G$، گرامر $G'$ وجود دارد که هیچ لاندا قاعده‌ای نداشته باشد و همچنین
	 	$L(G') = L(G) - \{\Lambda\}$.
	 \end{theorem}
 	\begin{proof}
 		مراجعه شود به صفحه ۱۵۰ کتاب مارتین.
 	\end{proof}
	  \begin{theorem}
	 	برای هر گرامر بدون لاندا-قاعده $G$، گرامر $G'$ وجود دارد که هیچ یونیت پروداکشنی نداشته باشد و همچنین
	 	$L(G') = L(G) - \{\Lambda\}$.
	 \end{theorem}
	 \begin{proof}
	 	مراجعه شود به صفحه ۱۵۲ کتاب مارتین.
	 \end{proof}
 \begin{definition}
 	گرامر $G$ به فرم نرمال چامسکی است اگر هر قاعده گرامر به فرم 
 	$A \rightarrow BC$
 	یا 
 	 $A \rightarrow \Lambda$
 	 باشد.
 \end{definition}
	  \begin{theorem}
	برای هر گرامر مستقل از متن $G$، گرامر $G'$ به فرم نرمال چامسکی وجود دارد که 
	$L(G') = L(G) - \{\Lambda\}$.
\end{theorem}
	\begin{proof}
	مراجعه شود به صفحه ۱۵۲ و ۱۵۳ کتاب مارتین.
\end{proof}
	الگوریتم 
	CYK
	برای بررسی وجود یک کلمه در زبان تولیدشده توسط یک گرامر مستقل از متن استفاده می‌شود. کاربرد آن در بخش تجزیه 
	\LTRfootnote{Parser}
	کامپایلرها است. این الگوریتم همچنین نحوه اشتقاق کلمه را نیز نشان می‌دهد یعنی اینکه در هر مرحله از کدام قاعده استفاده شود تا کلمه تولید شود. برای ورودی، این الگوریتم نیاز دارد تا گرامر ورودی به فرم نرمال چامسکی باشد. با مراجعه به کتاب مارتین نحوه تبدیل گرامر دلخواه به فرم چامسکی را به صورت الگوریتمی ببینید. 
	
	\end{document}